// Generated by CoffeeScript 1.7.1
(function() {
  var PolygonIndex, Result;

  Result = require('../result');

  PolygonIndex = require('rbush');

  PolygonIndex.prototype.add = function(id, polygon) {
    polygon.id = id;
    this.insert(polygon);
    return null;
  };

  PolygonIndex.prototype.search = function(target) {
    var child, childBBox, d, group, groups, node, nodesToSearch, result, _i, _len, _ref;
    node = this.data;
    groups = {};
    result = new Result();
    if (!this._inside(target, node.bbox)) {
      return result;
    }
    nodesToSearch = [];
    while (node != null) {
      _ref = node.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        childBBox = node.leaf ? this.toBBox(child) : child.bbox;
        if (node.leaf != null) {
          d = this._distance(child.location, target);
          if (groups[child.group] == null) {
            groups[child.group] = {
              dist: d,
              polygon: child
            };
          } else if (this._further(groups[child.group].dist, d) && this._hitByRaycast(target, child)) {
            groups[child.group].dist = d;
            groups[child.group].polygon = child;
          }
        } else if (this._inside(target, childBBox)) {
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    for (group in groups) {
      result.add(groups[group].polygon.id);
    }
    return result;
  };

  PolygonIndex.prototype.toBBox = function(polygon) {
    var maxX, maxY, minX, minY, p, _i, _len, _ref;
    minX = polygon.points[0][0];
    minY = polygon.points[0][1];
    maxX = minX;
    maxY = minY;
    _ref = polygon.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      minX = Math.min(minX, p[0]);
      minY = Math.min(minY, p[1]);
      maxX = Math.max(maxX, p[0]);
      maxY = Math.max(maxY, p[1]);
    }
    return [minX, minY, maxX, maxY];
  };

  PolygonIndex.prototype._inside = function(target, bbox) {
    return target[0] > bbox[0] && target[1] > bbox[1] && target[0] < bbox[2] && target[1] < bbox[3];
  };

  PolygonIndex.prototype._hitByRaycast = function(target, polygon) {
    var hit, i, j, l, pointi, pointj, x, y;
    if (!this._inside(target, this.toBBox(polygon))) {
      return false;
    }
    hit = false;
    l = polygon.points.length;
    i = 0;
    j = l - 1;
    x = target[0];
    y = target[1];
    while (i < l) {
      pointi = polygon.points[i];
      pointj = polygon.points[j];
      if ((pointi[1] >= y) !== (pointj[1] >= y) && (x <= (pointj[0] - pointi[0]) * (y - pointi[1]) / (pointj[1] - pointi[1]) + pointi[0])) {
        hit = !hit;
      }
      j = i;
      i++;
    }
    return hit;
  };

  PolygonIndex.prototype._distance = function(point, target) {
    var x, y;
    x = point[0] - target[0];
    y = point[1] - target[1];
    return Math.sqrt(x * x + y * y);
  };

  PolygonIndex.prototype._further = function(current, target) {
    if (current < 1000) {
      return false;
    }
    return current > target;
  };

  module.exports = PolygonIndex;

}).call(this);
