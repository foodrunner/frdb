// Generated by CoffeeScript 1.7.1
(function() {
  var Helper, IDSet, PolygonIndex;

  IDSet = require('../id_set');

  Helper = require('../helper');

  PolygonIndex = require('rbush');

  PolygonIndex.prototype.add = function(group_id, polygons) {
    var polygon, _i, _len;
    if (!(polygons instanceof Array)) {
      polygons = [polygons];
    }
    for (_i = 0, _len = polygons.length; _i < _len; _i++) {
      polygon = polygons[_i];
      polygon.group = group_id;
      this.insert(polygon);
    }
    return null;
  };

  PolygonIndex.prototype.search = function(target) {
    var child, childBBox, d, group, groups, node, nodesToSearch, set, _i, _len, _ref;
    node = this.data;
    groups = {};
    set = new IDSet();
    if (!this._inside(target, node.bbox)) {
      return set;
    }
    nodesToSearch = [];
    while (node != null) {
      _ref = node.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        childBBox = node.leaf ? this.toBBox(child) : child.bbox;
        if (node.leaf != null) {
          d = Helper.distanceBetween(child.location, target);
          if (groups[child.group] == null) {
            groups[child.group] = {
              dist: d,
              polygon: child
            };
          } else if (this._further(groups[child.group].dist, d) && this._hitByRaycast(target, child)) {
            groups[child.group].dist = d;
            groups[child.group].polygon = child;
          }
        } else if (this._inside(target, childBBox)) {
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    for (group in groups) {
      set.add(group);
    }
    return set;
  };

  PolygonIndex.prototype.toBBox = function(polygon) {
    var maxX, maxY, minX, minY, p, _i, _len, _ref;
    minX = polygon.points[0][0];
    minY = polygon.points[0][1];
    maxX = minX;
    maxY = minY;
    _ref = polygon.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      minX = Math.min(minX, p[0]);
      minY = Math.min(minY, p[1]);
      maxX = Math.max(maxX, p[0]);
      maxY = Math.max(maxY, p[1]);
    }
    return [minX, minY, maxX, maxY];
  };

  PolygonIndex.prototype._inside = function(target, bbox) {
    return target[0] > bbox[0] && target[1] > bbox[1] && target[0] < bbox[2] && target[1] < bbox[3];
  };

  PolygonIndex.prototype._hitByRaycast = function(target, polygon) {
    if (!this._inside(target, this.toBBox(polygon))) {
      return false;
    }
    return Helper.hitByRaycast(target, polygon.points);
  };

  PolygonIndex.prototype._further = function(current, target) {
    if (current < 1000) {
      return false;
    }
    return current > target;
  };

  module.exports = PolygonIndex;

}).call(this);
